{"name":"oojs","tagline":"Make Codes Easy!","body":"oojs - make codes easy!\r\n===================================  \r\n简单, 是一种美、一种哲学、一种信仰.\r\noojs提供了最佳的javascript编程方式, 让代码更加简单的编写、阅读和维护.\r\n\r\n**oojs 代码示例**:\r\n```js\r\n//创建cookie类\r\noojs.define({\r\n    name: 'cookie',                 //类名\r\n    namespace: 'oojs.utility',      //命名空间\r\n    prefix: 'prefix-',              //属性\r\n    getCookie:function(key){...}    //函数\r\n});\r\n\r\n//使用cookie类\r\nvar cookie = oojs.using('oojs.utility.cookie');\r\nvar id = cookie.getCookie('id');\r\n```\r\n\r\noojs是 **编程框架** 而非 **类库** , 适用于所有的js项目, 可以和各种规范如ADM,CDM等一起使用. \r\noojs中的oo即面向对象(Object Oriented), **对象是组织代码的最小单位.** \r\n\r\n**oojs 核心理念**:\r\n> 万物皆对象\r\n> 对象皆JSON\r\n\r\n**oojs 主要功能**:\r\n> 使用JSON结构描述类.\r\n> 使用命名空间组织类.\r\n> 兼容node和浏览器环境.\r\n\r\n---\r\n\r\n#传统的JS编程方式\r\n\r\n首先, 让我们了解为何传统js编程方式会导致代码的可读性下降. \r\n因为js的灵活性, 在开发中经常会出现孤零的变量和函数, 比如:\r\n```js\r\nvar a = function(){return b};\r\nvar b = 'hello';\r\nvar c = a();\r\nfunction d(){\r\n    //...\r\n}\r\n```\r\n所以我们常常见到这样组织代码的:\r\n```js\r\nvar property1 = 'a';\r\nfunction method1(){...};\r\nvar property2 = 'b';\r\nfunction method2(){...};\r\nvar property3 = '';\r\nif(property1==='a'){\r\n    property3 = 'c';\r\n    var method3 = method1(property3);\r\n}\r\n```\r\n\r\n\r\n再加上匿名函数和闭包的乱入:\r\n```js\r\n//匿名函数和闭包举例\r\nvar property4 = 'd';\r\nvar method4 = method1(function(){\r\n    function(){\r\n        return property4;\r\n    }\r\n})\r\n```\r\n即使是有名的js项目或者大神们编写的代码已经尽量清晰的去组织变量和代码, 当代码量过多时也必然会导致可读性下降.\r\n本质原因是传统的js开发 **将变量作为了组织代码的最小单位** .\r\n\r\noojs的思想是 **将对象作为组织代码的最小单位** . 实际上, 已经有很多的开发者意识到了这一问题.比如在最新版本的jQuery中源码, 已经通过使用JSON对象提高了代码可读性:\r\n```js\r\njQuery.extend({\r\n\t// Unique for each copy of jQuery on the page\r\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\r\n\r\n\t// Assume jQuery is ready without the ready module\r\n\tisReady: true,\r\n\r\n\terror: function( msg ) {\r\n\t\tthrow new Error( msg );\r\n\t},\r\n    ...\r\n\tnoop: function() {}\r\n});\r\n```\r\n由此可见, **使用JSON字面量创建对象, 是最自然的面向对象编程方式.**\r\n\r\n基于此, oojs诞生了.\r\n\r\n---\r\n# oojs入门\r\n\r\n**名词解释-全限定性名**:  命名空间+类名.比如类C, 所在的命名空间是A.B, 则C的全限定性名是A.B.C\r\n\r\n## 简单示例\r\n下面是一个简单的node程序示例.\r\n```js\r\n//node环境下引用oojs\r\nrequire('node-oojs');\r\n\r\n//定义cookie类\r\noojs.define({\r\n    name: 'cookie',\r\n    namespace: 'oojs.utility',\r\n    getCookie:function(key){...},\r\n    setCookie:function(key, value, option){...}\r\n});\r\n\r\n//使用cookie类, 因为cookie是静态类所以不需要实例化\r\nvar cookie = oojs.using('oojs.utility.cookie');\r\n\r\n//使用cookie类的getCookie函数\r\nvar id = cookie.getCookie('id');\r\n```\r\n在oojs中, 使用JSON结构声明一个类. 通过oojs.define完成类的定义. 通过oojs.using获取到类的引用. \r\n\r\n\r\n## 开始使用\r\n\r\n下面详细的讲解使用oojs的步骤.\r\n\r\n### 1. 引用oojs\r\noojs支持浏览器和node环境. 使用oojs的第一步就是引入oojs.\r\n\r\n#### node 环境\r\n使用npm或者cnpm安装最新版本的oojs. **注意oojs的npm模块名称叫做\"node-oojs\"**(因为npm上的oojs名字已经被占用).\r\n在项目根目录运行npm命令:\r\n```js\r\nnpm install node-oojs\r\n```\r\n在程序的入口处引用:\r\n```js\r\nrequire('node-oojs');\r\n```\r\n整个程序进程只需要引用一次. \r\n\r\n\r\n#### 浏览器环境\r\n在浏览器环境下, 需要手动下载oojs文件. 项目地址:\r\n```html\r\nhttps://github.com/zhangziqiu/oojs\r\n```\r\n\r\noojs项目的bin目录下面, 有两个js文件:\r\n\r\n* oojs.core.js: 仅包括核心的面向对象编程功能.\r\n* oojs.js: 除了核心功能, 还包括loader类用于加载依赖类. 以及event类用于处理事件编程. 通常都加载此文件.\r\n\r\n将oojs.js下载到项目中后, 直接引用即可:\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"./bin/oojs.js\"></script>\r\n```\r\n\r\n### 2. 创建类\r\n在 **[项目根目录]/src/utility** 目录下创建template.js文件, 内容如下:\r\n\r\n```js\r\n    //template类提供一个render方法用于模板和数据的拼接\r\n\toojs.define({\r\n\t\tname: 'template',\r\n\t\tnamespace: 'utility',\r\n\t\trender: function (source, data) {\r\n\t\t\tvar regexp = /{(.*?)}/g;\r\n\t\t\treturn source.replace(regexp, function (match, subMatch, index, s) {\r\n\t\t\t\treturn data[subMatch] || \"\";\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n```\r\n上面就是一个完整类的代码. 在oojs中, js类文件都是以oojs.define开始, 里面包括一个JSON格式的对象. 开发者可以自由的添加属性和方法, 但是要注意   **此JSON对象的以下属性是oojs框架使用的:**    \r\n    \r\n* name: 类名, 比如上面的 template\r\n* namespace: 类所在的命名空间. 比如template类放在了 utility 命名空间下. 我们可以将所有的工具类都放在utility命名空间下,实现类的组织管理.\r\n* 名字为 **\"类名\"** 的函数(比如template类的template函数): 类的构造函数. 使用 oojs.create 创建一个类实例时, 会执行一次构造函数. \r\n* 名字为 **\"$+类名\"** 的函数(比如template类的$template函数): 类的静态构造函数. 当使用oojs.define将一个类引入时, 会执行一次静态构造函数. 创建实例的时候不会执行. 多次执行oojs.define只有第一次引入时会调用一次.\r\n* deps: 依赖的类. 使用object描述. key为引用变量名, value为类的全限定性名. 后续可以通过this.key引用到这个依赖类. **在构造函数和静态构造函数执行时,所有的deps依赖类都已经加载完毕.可以安全的使用依赖类.** 在构造函数或者静态构造函数中可以放心的使用this.key的方式使用依赖类. 有关加载依赖的详细说明后面会有单独的章节讲解.\r\n\r\n### 3. 使用类\r\n现在我们已经有了一个template类. 下面介绍如何在不同的环境下使用template类.\r\n#### 3.1 创建入口类\r\n通常程序都有一个main函数作为程序入口, 在oojs中稍有不同, 借助oojs的依赖管理和静态构造函数, 我们可以构造一个入口类main.js: \r\n```js\r\n    oojs.define({\r\n        name: 'main',\r\n        deps: { template: 'utility.template' },\r\n        $main: function(){\r\n            var result = this.template.render('My name is {name}', {name:'ZZQ'});\r\n            console.log(result);\r\n        }\r\n    });\r\n```\r\nmain.js可以放置在任意目录,而且也没有命名空间. main的静态构造函数$main作为程序的入口, 在静态构造函数中通过\"this.template\"的引用到template类. \r\n\r\n#### 3.2 node环境运行\r\n在node环境中运行main.js, 需要在main.js顶部添加引用oojs库的代码:\r\n\r\n```js\r\n    //引用oojs库\r\n    require('node-oojs');\r\n    //后面就是main类的完整代码.\r\n    oojs.define({\r\n        name: 'main',\r\n        deps: { template: 'utility.template' },\r\n        $main: function(){\r\n            var result = this.template.render('My name is {name}', {name:'ZZQ'});\r\n            console.log(result);\r\n        }\r\n    });\r\n```\r\n\r\n运行:\r\n```js\r\n    node main.js\r\n```\r\n即可看到输出结果:\r\n```js\r\n    My name is ZZQ\r\n```\r\n\r\n在node环境下, 当加载 utility.template 类时, 默认会从如下路径加载类文件:\r\n```js\r\n[node运行目录]/src/utility/template.js\r\n```\r\n即将 [node运行根目录]/src 目录作为代码存放的根目录, 每一个命名空间就是一个文件夹.\r\n\r\n#### 3.3 浏览器环境\r\n假设项目目录就是网站的根目录, 并且网站名称是 localhost. \r\n在根目录下创建main.html, 编写如下代码:\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <body>\r\n        <!-- 引入oojs, 假设将oojs.js下载到了src目录中 -->\r\n        <script type=\"text/javascript\" src=\"./src/oojs.js\"></script>\r\n        <!-- 设置类文件根目录 -->\r\n        <script>\r\n            oojs.setPath('http://localhost/src/');\r\n        </script>\r\n        <script>\r\n                //下面是main.js的内容, 可以将main直接写在页面里\r\n                oojs.define({\r\n                    name: 'main',\r\n                    deps: { template: 'utility.template' },\r\n                    $main: function(){\r\n                        var result = this.template.render('My name is {name}', {name:'ZZQ'});\r\n                        console.log(result);\r\n                    }\r\n                });\r\n        </script>\r\n    </body>\r\n</html>\r\n```\r\n\r\n打开 http://localhost/main.html页面, 即可在console控制台中看到:\r\n```js\r\n    My name is ZZQ\r\n```\r\n\r\n在浏览器中使用时, 需要设置类文件的根目录.oojs框架将从指定的根目录, 使用异步的方式加载类. 比如上面的例子加载 utility.template 类的地址是:\r\n```js\r\n    http://localhost/src/utility/template.js\r\n```\r\n如果main有多个依赖类, 会同时并行异步加载, 并且在所有的类都加载完毕后在运行$main静态构造函数. \r\n\r\n通过上面实例的详细讲解, 已经可以使用oojs编写简单可维护的js代码了.\r\n下面的篇幅会介绍一些oojs细节和高级用法.\r\n\r\n---\r\n\t\t\r\n## 类的加载路径\r\n\r\n使用oojs的项目代码是用类组织的.在入门示例中, template.js 加载时, 默认使用如下路径:\r\n\r\n***node:***\r\n[node运行的目录]/src/utility/template.js\r\n\r\n***浏览器:***\r\n[页面当前域名]/src/utility/template.js\r\n\r\n即无论是node还是浏览器, 在项目的根目录里创建src文件夹, src内根据命名空间来组织文件夹.\r\n\r\noojs提供了setPath函数, 可以为特定的类或者命名空间指定自己特殊的加载路径.\r\n\r\n```js\r\n//设置全局根目录\r\noojs.setPath('./src2/');\r\noojs.setPath('http://localhost/asset/js/');\r\n\r\n//为 A 和 A.B 命名空间设置特殊的加载路径\r\noojs.setPath({\r\n    'A':'./src1/A/',\r\n    'A.B':'./src2/A/B/'\r\n});\r\n```\r\noojs的路径查找使用的是树状结构. 以\"A.B.C\"这个类的查找规则为例:\r\n\r\n* 首先从root根目录查找. 此时path为默认的src目录.\r\n* 查找命名空间A, 发现通过setPath设置了A的路径, 此时path为上面设置的 './src1/A'\r\n* 查找命名空间A.B, 发现通过setPath设置了A.B的路径, 此时path为上面设置的 './src2/A/B/'\r\n* 查找命名空间A.B.C, 未发现A.B.C的路径, 于是使用上一步的path作为结果返回\r\n\r\n通过上面的查找行为可以看出, 优先使用更加精确的类的加载路径, 否则使用父路径.\r\n\r\n---\r\n     \r\n# oojs的git源码结构\r\n\r\n## bin目录\r\nbin目录中, 用于存放编译后的文件. bin目录下有以下两个js文件:\r\n\r\n* oojs.core.js: 压缩后的文件. 仅包括核心的面向对象编程功能.\r\n* oojs.js: 压缩后的文件. 除了核心功能, 还包括loader类用于加载依赖类.以及event类用于处理事件编程. 通常都加载此文件.\r\n\r\n在bin的根目录下, 放置的是代码压缩后的js文件. 通常在项目中引用的就是代码压缩后的js文件. 同时为了应对一些比如调试等场景, bin目录下还包括如下文件夹: \r\n\r\n* format文件夹: 格式化,但是无注释的编译结果\r\n* gzip文件夹: gzip后的编译结果\r\n* source文件夹: 包含注释的编译结果\r\n\r\n上面每一个文件夹中, 也都包含 oojs.core.js和oojs.js两个文件(gzip目录下是.gz后缀), 可以根据需要使用.\r\n\r\n## src目录\r\nsrc目录存放oojs的源码文件. oojs框架自身也是按照oojs的编程方式实现的, 即oojs是自解析的. \r\n\r\n* oojs文件夹 : oojs命名空间\r\n    * event.js : oojs.event类实现了事件编程和promise编程模式. 这是异步编程时必不可少的类.\r\n    * loader.js : oojs.loader类提供了浏览器环境加载依赖类的加载器. \r\n* oojs.js : oojs的核心编程框架. oojs.core.js就是直接从这个文件编译出来的.\r\n    \r\n## 项目根目录\r\nbin和src两个目录是最主要的文件夹. 除了这两个文件夹, oojs的项目根目录还包括如下文件:\r\n\r\n* .gitignore: git配置文件, 里面写明了git不需要管理的文件. 比如 node_modules 文件夹.\r\n\r\n* README.md: 说明文档. 即您正在阅读的这个页面的内容.\r\n\r\n* make.js: 编译文件. 使用 node make.js 命令, 可以从src目录生成bin目录下面的所有文件.\r\n\r\n* package.json: 包描述文件.\r\n\r\n---\r\n    \r\n# 事件函数与this指针\r\n假设我们声明了一个类:\r\n```js\r\n    oojs.define({\r\n        name:'myClass',\r\n        word: 'Hello World',\r\n        say: function(){\r\n            alert(this.word);\r\n        }\r\n    })\r\n```\r\nmyClss类有一个say函数, 输出myClass类的word属性. say函数中通过this引用myClass类自身. 这在通常情况下都是正确的.\r\n\r\n但是在事件中, 比如常见的按钮单击事件, 或者一个定时器函数, this指针并不是总指向myClass自身的:\r\n```js\r\n    window.word = 'I am window';\r\n    var myClass = oojs.using('myClass');\r\n    setTimeout(myClass.say, 1000);\r\n```\r\n上面的代码会输出\"I am window\"而不是myClass类中的\"Hello World\". 因为在setTimeout中的this指向了window对象而不是myClass.\r\n\r\noojs提供了proxy函数用于解决this指针问题. 默认情况下为了使用方便, 会为function的原型添加proxy函数. 如果不希望对原型造成污染也可以通过配置取消此功能. \r\n\r\nproxy函数用来修改事件的this指针. 比如上面的代码可以这样修改:\r\n```js\r\n    var myClass = oojs.using('myClass');\r\n    setTimeout(myClass.say.proxy(myClass), 1000);\r\n```\r\n使用了proxy之后, 可以正常的输出\"Hello World\".\r\n\r\nproxy函数的第一个参数表示this指针需要指向的对象. \r\n\r\nproxy函数还可以 ***修改事件处理函数的签名*** , 下面举一个复杂的例子.\r\n\r\n在nodejs中, 系统提供了socket对象, 用于网络编程. \r\n```js\r\nvar net = require('net');\r\nvar client = net.connect({port: 8124},\r\n    function() { //'connect' listener\r\n          console.log('client connected');\r\n          client.write('world!\\r\\n');\r\n});\r\n```\r\n调用 net.connect函数时, 需要传递一个回调函数, 并且回调函数是无参数的.\r\n通常, 使用上面的例子, 我们传递了一个匿名的回调函数, 并且在这个回调函数中使用 client变量, 此时会生成一个闭包, 以便在回调函数执行时, 可以正确访问到client变量.\r\n\r\n使用proxy函数, 可以用一种 ***显式闭包*** 的方式, 将client作为参数传递, 让其看起来是通过参数传递的而不是使用闭包:\r\n\r\n```js\r\nvar net = require('net');\r\nvar client = net.connect({port: 8124},\r\n    function(mySocket) { //'connect' listener\r\n          console.log('client connected');\r\n          mySocket.write('world!\\r\\n');\r\n}.proxy(this, client));\r\n```\r\n注意, 这里通过proxy除了传递this对象外, 还传递了client变量.\r\nconnect原本的回调函数是没有签名的, 但是你会发现在回调函数执行时, mySocket可以被正常访问. 此时我们将原本无参数的事件处理函数, 变成了一个有参数的事件处理函数. \r\n\r\nproxy函数看似神奇,其实内部还是使用闭包实现. 所以我在这里称其为 ***显式闭包*** .\r\n使用显示闭包极大的增加了代码的可读性和可维护性. 可以说显示闭包让邪恶的闭包从良了.\r\n\r\n另外, 显示闭包还可以解决循环中使用闭包的常见错误, 看下面的例子:\r\n(参见:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)\r\n\r\n```html\r\n<p id=\"help\">Helpful notes will appear here</p>\r\n<p>E-mail: <input type=\"text\" id=\"email\" name=\"email\"></p>\r\n<p>Name: <input type=\"text\" id=\"name\" name=\"name\"></p>\r\n<p>Age: <input type=\"text\" id=\"age\" name=\"age\"></p>\r\n```\r\n\r\n```js\r\nfunction showHelp(help) {\r\n  document.getElementById('help').innerHTML = help;\r\n}\r\n\r\nfunction setupHelp() {\r\n  var helpText = [\r\n      {'id': 'email', 'help': 'Your e-mail address'},\r\n      {'id': 'name', 'help': 'Your full name'},\r\n      {'id': 'age', 'help': 'Your age (you must be over 16)'}\r\n    ];\r\n\r\n  for (var i = 0; i < helpText.length; i++) {\r\n    var item = helpText[i];\r\n    document.getElementById(item.id).onfocus = function() {\r\n      showHelp(item.help);\r\n    }\r\n  }\r\n}\r\n\r\nsetupHelp();\r\n```\r\n数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。\r\n\r\n运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。\r\n\r\n该问题的原因在于赋给 onfocus 是闭包（showHelp）中的匿名函数而不是闭包对象；在闭包（showHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。\r\n\r\n使用proxy函数就不会出现上面的问题:\r\n```js\r\n    document.getElementById(item.id).onfocus = function(ev, item) {\r\n      showHelp(item.help);\r\n    }.proxy(this, item);\r\n```\r\n特别要注意, proxy函数只能在原有的事件处理函数后面新增参数. onfocus事件原本是包括一个事件对象参数的. 即上面的ev. 所以需要将item作为第二个函数参数使用.\r\n\r\n相对于传统的node变成, 下面来看看使用oojs实现的完整的socket服务器的例子:\r\n```js\r\nrequire('node-oojs');\r\n\r\n\r\noojs.define({\r\n    name: 'socketServer',    \r\n    /**\r\n     * 静态构造函数\r\n     */\r\n    $socketServer: function () {\r\n        var net = require('net');\r\n\t\t\r\n        //启动服务\r\n        this.server = net.createServer();\r\n        this.server.on('connection', this.onConnection.proxy(this));\r\n        this.server.on('error', this.onError.proxy(this));\r\n        this.server.listen(8088, function () {\r\n            base.log.info('server bound');\r\n        });\r\n    },\r\n\r\n    /**\r\n     * 服务器连接事件处理函数. \r\n     * @param {Object} socket 本次连接的socket对象\r\n     */\r\n    onConnection: function (socket) {\r\n        socket.on('data', this.onData.proxy(this, socket));\r\n        socket.on('end', this.onEnd.proxy(this, socket));\r\n        socket.on('error', this.onError.proxy(this, socket));\r\n    },\r\n\r\n     /**\r\n     * socket接收数据事件处理函数. \r\n     * @param {Object} data 本次介绍到的数据对象buffer\r\n     * @param {Object} socket 本次连接的socket对象\r\n     */\r\n    onData: function (data, socket) {\r\n        //do something...\r\n    },\r\n\r\n    /**\r\n     * socket 关闭事件处理函数. \r\n     * @param {Object} socket 本次连接的socket对象\r\n     */\r\n    onEnd: function (socket) {\r\n        //do something...\r\n    },\r\n\r\n    /**\r\n     * socket 异常事件处理函数. \r\n     * @param {Object} err 异常对象\r\n     * @param {Object} socket 本次连接的socket对象\r\n     */\r\n    onError: function (err, socket) {\r\n        //do something...\r\n    }\r\n});\r\n```\r\n\r\n---\r\n\r\n#oojs的原型继承和快速克隆\r\noojs中使用特有的快速克隆方法实现高效的对象创建. 主要用在内部的oojs.create函数中, 此函数用于创建一个类实例.\r\n\r\n假设a是classA的一个实例. 此时的原型链情况如下:\r\n\r\n    a.contructor.prototype->classA\r\n\r\n当访问a的一个属性时, 有以下几种情况:\r\n\r\n1. 属性是值类型:\r\n    访问: 通过原型链获取到classA的属性\r\n    赋值: 在a对象上设置新的属性值, 再次访问时获取到的是a对象上的新值\r\n2. 属性是引用类型(比如object类型):\r\n    访问: 通过原型链获取到classA的属性\r\n    赋值: 因为是引用类型, 所以实际上是对classA上的引用对象赋值. 即classA被修改, 所有实例的此属性都被修改\r\n\r\n为了解决此问题, oojs在创建classA的实例时, 会遍历classA的属性, 如果发现属性的类型是引用类型, 则对其进行快速克隆:\r\n```js\r\n        /**\r\n         * 快速克隆方法\r\n         * @public\r\n         * @method fastClone\r\n         * @param {Object} source 带克隆的对象. 使用此方法克隆出来的对象, 如果source对象被修改, 则所有克隆对象也会被修改\r\n         * @return {Object} 克隆出来的对象.\r\n         */\r\n        fastClone: function (source) {\r\n            var temp = function () {};\r\n            temp.prototype = source;\r\n            var result = new temp();\r\n        }\r\n```\r\n传统的克隆对象是十分消耗性能的, oojs的最初也是用了传统的克隆方法. 最后改进成使用快速克隆方法. \r\n\r\n假设这个属性为A, 此时相当于将属性A作为类, 创建了一个属性A的实例, 即关系是:\r\n\r\n    a.A.constructor.prototype -> classA.A \r\n\r\n此时, 如果A的所有属性都不是引用类型, 则可以解决上面的赋值问题.\r\n但是如果属性A本身, 又含有引用类型, 则同样会出现赋值是修改原形的问题. \r\n假设: A.B为object\r\n则通过 a.A.B 获取到的对象与 classA.A.B 获取到的对象是同一个对象. 对于a.A.B的修改同样会影响到classA.A.B\r\n通过递归的快速克隆可以解决此问题, 但是因为性能开销太大, 所以oojs最后不支持多层的对象嵌套. \r\n\r\n实际上, 我们可以通过编程方式来解决这个问题.\r\n* 在类声明时赋值的属性, 即JSON中直接描述的属性值, 应该是静态static类型. 不应在运行时修改.\r\n* 如果一个属性是实例属性, 则应该在动态构造函数中赋值.比如:\r\n```js\r\noojs.define({\r\n    name: 'classA'\r\n    A: null\r\n    classA:function(){\r\n        this.A = { B:1 }\r\n    }\r\n});\r\n```\r\n\r\n所以一定要注意, 如果类的属性是对象, 并且是实例属性(运行时会被修改),则必须在动态构造函数中创建.\r\n\r\n另改一个问题就是a对象的遍历. 同样因为使用了原型继承, 不能够通过hasOwnProperty来判断一个属性是否是实例a的. 可以通过遍历classA来解决:\r\n```js\r\nfor(var key in a){\r\n    if(key && typeof a[key] !== 'undefined' && classA.hasOwnProperty(key)){\r\n        //do something...\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n#事件编程\r\njs中常常使用事件和异步, 在浏览器端的Ajax是异步, 在nodejs中更是到处都是异步事件.\r\n\r\n在异步事件的编程中, 常常会遇到多层嵌套的情况. 比如:\r\n\r\n```js\r\nvar render = function (template, data, l10n) {\r\n  //do something...\r\n};\r\n\r\n$.get(\"template\", function (template) {\r\n  // something\r\n  $.get(\"data\", function (data) {\r\n    // something\r\n    $.get(\"l10n\", function (l10n) {\r\n      // something\r\n      render(template, data, l10n);\r\n    });\r\n  });\r\n});\r\n```\r\n在异步的世界里, 需要在回调函数中获取调用结果, 然后再进行接下来的处理流程, 所以导致了回调函数的多层嵌套, 并且只能串行处理.\r\n\r\noojs提供了oojs.event, 来解决此问题. 比如要实现上面的功能, 可以进行如下改造:\r\n```js\r\nvar render = function (template, data, l10n) {\r\n  //do something...\r\n};\r\n\r\nvar ev = oojs.create(oojs.event);\r\nev.bind('l10n', function(data){\r\n    ev.emit('l10n', data);\r\n});\r\nev.bind('data', function(data){\r\n    ev.emit('data', data);\r\n});\r\nev.bind('template', function(data){\r\n    ev.emit('template', data);\r\n});\r\n//并行执行template, data和l10n事件, 都执行完毕后会触发group中的回调函数\r\nev.group('myGroup', ['template','data','l10n'], function(data){\r\n    render(data.template, data.data, data.l10n);\r\n});\r\n```\r\noojs.event的group可以将事件打包成一组. 在group的回调函数中, 会传递一个参数data, 这是一个object对象, 其中key为group中绑定的每一个事件名, value为事件的返回值. 所以可以通过data[事件名]获取到某一个事件的返回值. \r\n\r\noojs.event中的group还可以动态添加新的事件. 比如:\r\n```js\r\nev.group('myGroup', ['template','data','l10n'], function(data){\r\n    render(data.template, data.data, data.l10n);\r\n});\r\n\r\nev.group('myGroup', ['another'], function(data){\r\n    anotherData = data.another;\r\n});\r\n```\r\n注意上面的代码, 虽然为myGroup又添加了一个another事件. 但是此时mygroup绑定了两个事件处理函数, 这两个函数都会在所有事件完成时执行, 但是不一定哪个在前. 所以oojs.event还提供了afterGroup事件, 此事件会在所有group绑定的callback执行完毕后再执行:\r\n```js\r\nev.group('myGroup', ['template','data','l10n']);\r\n\r\nev.group('myGroup', ['another']);\r\n\r\nev.afterGroup('myGroup', function(data){\r\n    render(data.template, data.data, data.l10n, data.another);\r\n});\r\n```\r\n\r\noojs.event使用oo的思想实现. node中本身自带EventEmmiter也实现了部分功能. \r\n\r\n---\r\n\r\n# 为什么要用面向对象的思想写js?\r\n\r\noo不仅仅是一种编程方法, 而是组织代码的最小单位. \r\n\r\n看几个使用AMD规范的例子就会明白, AMD中最后一个参数factory虽然美其名曰构造函数, 但是在这个函数中, 你可以做任何事情:创建局部function, function中再嵌套function, 使用闭包, 处理一些业务逻辑. 最后的结果是这个factory不易阅读和维护.\r\n    \r\n究其原因, js编程很容易陷入面向过程编程的方式中. 而AMD等规范只注重\"模块\"的开发, 却忽视了一个模块内部的代码如何组织和管理.\r\n    \r\njs中让代码不易管理的几个杀手包括: 闭包, 零散的函数对象, 异步机制(node中尤其重要).\r\n    \r\noojs使用oo的思想, 减少闭包的使用, 让每一个函数对象都挂靠在类对象上, 减少孤零的函数对象的存在. 再配合oojs.event的事件机制, 解决异步编程中的事件嵌套噩梦.\r\n    \r\n可以说oojs为js的大规模开发提供了有效地基础保障.\r\n\r\n---\r\n\r\n# 加入我们\r\n   oojs还在发展中, 我们尽量不在核心的oojs.js中加入过多的功能, 保持核心精简. 同时通过oojs团队成员的努力, 让oojs适用于更多的场景. \r\n   \r\n   欢迎有志之士加入到oojs的开发中来! \r\n \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}