<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>oojs by zhangziqiu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">oojs</h1>
      <h2 class="project-tagline">Make Codes Easy!</h2>
      <a href="https://github.com/zhangziqiu/oojs" class="btn">View on GitHub</a>
      <a href="https://github.com/zhangziqiu/oojs/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/zhangziqiu/oojs/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="oojs---make-codes-easy" class="anchor" href="#oojs---make-codes-easy" aria-hidden="true"><span class="octicon octicon-link"></span></a>oojs - make codes easy!</h1>

<p>简单, 是一种美、一种哲学、一种信仰.
oojs提供了最佳的javascript编程方式, 让代码更加简单的编写、阅读和维护.</p>

<p><strong>oojs 代码示例</strong>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">//创建cookie类</span>
oojs.define({
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>cookie<span class="pl-pds">'</span></span>,                 <span class="pl-c">//类名</span>
    namespace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>oojs.utility<span class="pl-pds">'</span></span>,      <span class="pl-c">//命名空间</span>
    prefix<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>prefix-<span class="pl-pds">'</span></span>,              <span class="pl-c">//属性</span>
    <span class="pl-en">getCookie</span><span class="pl-k">:</span><span class="pl-k">function</span>(<span class="pl-smi">key</span>){...}    <span class="pl-c">//函数</span>
});

<span class="pl-c">//使用cookie类</span>
<span class="pl-k">var</span> cookie <span class="pl-k">=</span> oojs.using(<span class="pl-s"><span class="pl-pds">'</span>oojs.utility.cookie<span class="pl-pds">'</span></span>);
<span class="pl-k">var</span> id <span class="pl-k">=</span> cookie.getCookie(<span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>);</pre></div>

<p>oojs是 <strong>编程框架</strong> 而非 <strong>类库</strong> , 适用于所有的js项目, 可以和各种规范如ADM,CDM等一起使用. 
oojs中的oo即面向对象(Object Oriented), <strong>对象是组织代码的最小单位.</strong> </p>

<p><strong>oojs 核心理念</strong>:</p>

<blockquote>
<p>万物皆对象
对象皆JSON</p>
</blockquote>

<p><strong>oojs 主要功能</strong>:</p>

<blockquote>
<p>使用JSON结构描述类.
使用命名空间组织类.
兼容node和浏览器环境.</p>
</blockquote>

<hr>

<h1>
<a id="传统的js编程方式" class="anchor" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84js%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>传统的JS编程方式</h1>

<p>首先, 让我们了解为何传统js编程方式会导致代码的可读性下降. 
因为js的灵活性, 在开发中经常会出现孤零的变量和函数, 比如:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> <span class="pl-en">a</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){<span class="pl-k">return</span> b};
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>;
<span class="pl-k">var</span> c <span class="pl-k">=</span> a();
<span class="pl-k">function</span> <span class="pl-en">d</span>(){
    <span class="pl-c">//...</span>
}</pre></div>

<p>所以我们常常见到这样组织代码的:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> property1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>;
<span class="pl-k">function</span> <span class="pl-en">method1</span>(){...};
<span class="pl-k">var</span> property2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>;
<span class="pl-k">function</span> <span class="pl-en">method2</span>(){...};
<span class="pl-k">var</span> property3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>;
<span class="pl-k">if</span>(property1<span class="pl-k">===</span><span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>){
    property3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>;
    <span class="pl-k">var</span> method3 <span class="pl-k">=</span> method1(property3);
}</pre></div>

<p>再加上匿名函数和闭包的乱入:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">//匿名函数和闭包举例</span>
<span class="pl-k">var</span> property4 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>;
<span class="pl-k">var</span> method4 <span class="pl-k">=</span> method1(<span class="pl-k">function</span>(){
    <span class="pl-k">function</span>(){
        <span class="pl-k">return</span> property4;
    }
})</pre></div>

<p>即使是有名的js项目或者大神们编写的代码已经尽量清晰的去组织变量和代码, 当代码量过多时也必然会导致可读性下降.
本质原因是传统的js开发 <strong>将变量作为了组织代码的最小单位</strong> .</p>

<p>oojs的思想是 <strong>将对象作为组织代码的最小单位</strong> . 实际上, 已经有很多的开发者意识到了这一问题.比如在最新版本的jQuery中源码, 已经通过使用JSON对象提高了代码可读性:</p>

<div class="highlight highlight-js"><pre>jQuery.extend({
    <span class="pl-c">// Unique for each copy of jQuery on the page</span>
    expando<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>jQuery<span class="pl-pds">"</span></span> <span class="pl-k">+</span> ( version <span class="pl-k">+</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>() ).<span class="pl-c1">replace</span>(<span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-c1">\D</span><span class="pl-pds">/</span>g</span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> ),

    <span class="pl-c">// Assume jQuery is ready without the ready module</span>
    isReady<span class="pl-k">:</span> <span class="pl-c1">true</span>,

    <span class="pl-en">error</span><span class="pl-k">:</span> <span class="pl-k">function</span>( <span class="pl-smi">msg</span> ) {
        <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">Error</span>( msg );
    },
    ...
    <span class="pl-en">noop</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {}
});</pre></div>

<p>由此可见, <strong>使用JSON字面量创建对象, 是最自然的面向对象编程方式.</strong></p>

<p>基于此, oojs诞生了.</p>

<hr>

<h1>
<a id="oojs入门" class="anchor" href="#oojs%E5%85%A5%E9%97%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>oojs入门</h1>

<p><strong>名词解释-全限定性名</strong>:  命名空间+类名.比如类C, 所在的命名空间是A.B, 则C的全限定性名是A.B.C</p>

<h2>
<a id="简单示例" class="anchor" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>简单示例</h2>

<p>下面是一个简单的node程序示例.</p>

<div class="highlight highlight-js"><pre><span class="pl-c">//node环境下引用oojs</span>
<span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>node-oojs<span class="pl-pds">'</span></span>);

<span class="pl-c">//定义cookie类</span>
oojs.define({
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>cookie<span class="pl-pds">'</span></span>,
    namespace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>oojs.utility<span class="pl-pds">'</span></span>,
    <span class="pl-en">getCookie</span><span class="pl-k">:</span><span class="pl-k">function</span>(<span class="pl-smi">key</span>){...},
    <span class="pl-en">setCookie</span><span class="pl-k">:</span><span class="pl-k">function</span>(<span class="pl-smi">key</span>, <span class="pl-smi">value</span>, <span class="pl-smi">option</span>){...}
});

<span class="pl-c">//使用cookie类, 因为cookie是静态类所以不需要实例化</span>
<span class="pl-k">var</span> cookie <span class="pl-k">=</span> oojs.using(<span class="pl-s"><span class="pl-pds">'</span>oojs.utility.cookie<span class="pl-pds">'</span></span>);

<span class="pl-c">//使用cookie类的getCookie函数</span>
<span class="pl-k">var</span> id <span class="pl-k">=</span> cookie.getCookie(<span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span>);</pre></div>

<p>在oojs中, 使用JSON结构声明一个类. 通过oojs.define完成类的定义. 通过oojs.using获取到类的引用. </p>

<h2>
<a id="开始使用" class="anchor" href="#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>开始使用</h2>

<p>下面详细的讲解使用oojs的步骤.</p>

<h3>
<a id="1-引用oojs" class="anchor" href="#1-%E5%BC%95%E7%94%A8oojs" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 引用oojs</h3>

<p>oojs支持浏览器和node环境. 使用oojs的第一步就是引入oojs.</p>

<h4>
<a id="node-环境" class="anchor" href="#node-%E7%8E%AF%E5%A2%83" aria-hidden="true"><span class="octicon octicon-link"></span></a>node 环境</h4>

<p>使用npm或者cnpm安装最新版本的oojs. <strong>注意oojs的npm模块名称叫做"node-oojs"</strong>(因为npm上的oojs名字已经被占用).
在项目根目录运行npm命令:</p>

<div class="highlight highlight-js"><pre>npm install node<span class="pl-k">-</span>oojs</pre></div>

<p>在程序的入口处引用:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>node-oojs<span class="pl-pds">'</span></span>);</pre></div>

<p>整个程序进程只需要引用一次. </p>

<h4>
<a id="浏览器环境" class="anchor" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83" aria-hidden="true"><span class="octicon octicon-link"></span></a>浏览器环境</h4>

<p>在浏览器环境下, 需要手动下载oojs文件. 项目地址:</p>

<div class="highlight highlight-html"><pre>https://github.com/zhangziqiu/oojs</pre></div>

<p>oojs项目的bin目录下面, 有两个js文件:</p>

<ul>
<li>oojs.core.js: 仅包括核心的面向对象编程功能.</li>
<li>oojs.js: 除了核心功能, 还包括loader类用于加载依赖类. 以及event类用于处理事件编程. 通常都加载此文件.</li>
</ul>

<p>将oojs.js下载到项目中后, 直接引用即可:</p>

<div class="highlight highlight-html"><pre>&lt;<span class="pl-ent">script</span> <span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>text/javascript<span class="pl-pds">"</span></span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">"</span>./bin/oojs.js<span class="pl-pds">"</span></span>&gt;&lt;/<span class="pl-ent">script</span>&gt;</pre></div>

<h3>
<a id="2-创建类" class="anchor" href="#2-%E5%88%9B%E5%BB%BA%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 创建类</h3>

<p>在 <strong>[项目根目录]/src/utility</strong> 目录下创建template.js文件, 内容如下:</p>

<div class="highlight highlight-js"><pre>    <span class="pl-c">//template类提供一个render方法用于模板和数据的拼接</span>
    oojs.define({
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>template<span class="pl-pds">'</span></span>,
        namespace<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>utility<span class="pl-pds">'</span></span>,
        <span class="pl-en">render</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">source</span>, <span class="pl-smi">data</span>) {
            <span class="pl-k">var</span> regexp <span class="pl-k">=</span> /{(.<span class="pl-k">*?</span>)}/g;
            <span class="pl-k">return</span> source.<span class="pl-c1">replace</span>(regexp, <span class="pl-k">function</span> (<span class="pl-smi">match</span>, <span class="pl-smi">subMatch</span>, <span class="pl-smi">index</span>, <span class="pl-smi">s</span>) {
                <span class="pl-k">return</span> data[subMatch] <span class="pl-k">||</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
            });
        }
    });</pre></div>

<p>上面就是一个完整类的代码. 在oojs中, js类文件都是以oojs.define开始, 里面包括一个JSON格式的对象. 开发者可以自由的添加属性和方法, 但是要注意   <strong>此JSON对象的以下属性是oojs框架使用的:</strong>    </p>

<ul>
<li>name: 类名, 比如上面的 template</li>
<li>namespace: 类所在的命名空间. 比如template类放在了 utility 命名空间下. 我们可以将所有的工具类都放在utility命名空间下,实现类的组织管理.</li>
<li>名字为 <strong>"类名"</strong> 的函数(比如template类的template函数): 类的构造函数. 使用 oojs.create 创建一个类实例时, 会执行一次构造函数. </li>
<li>名字为 <strong>"$+类名"</strong> 的函数(比如template类的$template函数): 类的静态构造函数. 当使用oojs.define将一个类引入时, 会执行一次静态构造函数. 创建实例的时候不会执行. 多次执行oojs.define只有第一次引入时会调用一次.</li>
<li>deps: 依赖的类. 使用object描述. key为引用变量名, value为类的全限定性名. 后续可以通过this.key引用到这个依赖类. <strong>在构造函数和静态构造函数执行时,所有的deps依赖类都已经加载完毕.可以安全的使用依赖类.</strong> 在构造函数或者静态构造函数中可以放心的使用this.key的方式使用依赖类. 有关加载依赖的详细说明后面会有单独的章节讲解.</li>
</ul>

<h3>
<a id="3-使用类" class="anchor" href="#3-%E4%BD%BF%E7%94%A8%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 使用类</h3>

<p>现在我们已经有了一个template类. 下面介绍如何在不同的环境下使用template类.</p>

<h4>
<a id="31-创建入口类" class="anchor" href="#31-%E5%88%9B%E5%BB%BA%E5%85%A5%E5%8F%A3%E7%B1%BB" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 创建入口类</h4>

<p>通常程序都有一个main函数作为程序入口, 在oojs中稍有不同, 借助oojs的依赖管理和静态构造函数, 我们可以构造一个入口类main.js: </p>

<div class="highlight highlight-js"><pre>    oojs.define({
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>main<span class="pl-pds">'</span></span>,
        deps<span class="pl-k">:</span> { template<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>utility.template<span class="pl-pds">'</span></span> },
        $<span class="pl-en">main</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
            <span class="pl-k">var</span> result <span class="pl-k">=</span> <span class="pl-v">this</span>.template.render(<span class="pl-s"><span class="pl-pds">'</span>My name is {name}<span class="pl-pds">'</span></span>, {name<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>ZZQ<span class="pl-pds">'</span></span>});
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(result);
        }
    });</pre></div>

<p>main.js可以放置在任意目录,而且也没有命名空间. main的静态构造函数$main作为程序的入口, 在静态构造函数中通过"this.template"的引用到template类. </p>

<h4>
<a id="32-node环境运行" class="anchor" href="#32-node%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 node环境运行</h4>

<p>在node环境中运行main.js, 需要在main.js顶部添加引用oojs库的代码:</p>

<div class="highlight highlight-js"><pre>    <span class="pl-c">//引用oojs库</span>
    <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>node-oojs<span class="pl-pds">'</span></span>);
    <span class="pl-c">//后面就是main类的完整代码.</span>
    oojs.define({
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>main<span class="pl-pds">'</span></span>,
        deps<span class="pl-k">:</span> { template<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>utility.template<span class="pl-pds">'</span></span> },
        $<span class="pl-en">main</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
            <span class="pl-k">var</span> result <span class="pl-k">=</span> <span class="pl-v">this</span>.template.render(<span class="pl-s"><span class="pl-pds">'</span>My name is {name}<span class="pl-pds">'</span></span>, {name<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>ZZQ<span class="pl-pds">'</span></span>});
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(result);
        }
    });</pre></div>

<p>运行:</p>

<div class="highlight highlight-js"><pre>    node main.js</pre></div>

<p>即可看到输出结果:</p>

<div class="highlight highlight-js"><pre>    My name is <span class="pl-c1">ZZQ</span></pre></div>

<p>在node环境下, 当加载 utility.template 类时, 默认会从如下路径加载类文件:</p>

<div class="highlight highlight-js"><pre>[node运行目录]/src/utility/template.js</pre></div>

<p>即将 [node运行根目录]/src 目录作为代码存放的根目录, 每一个命名空间就是一个文件夹.</p>

<h4>
<a id="33-浏览器环境" class="anchor" href="#33-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.3 浏览器环境</h4>

<p>假设项目目录就是网站的根目录, 并且网站名称是 localhost. 
在根目录下创建main.html, 编写如下代码:</p>

<div class="highlight highlight-html"><pre>&lt;!DOCTYPE html&gt;
&lt;<span class="pl-ent">html</span>&gt;
    &lt;<span class="pl-ent">body</span>&gt;
        <span class="pl-c">&lt;!-- 引入oojs, 假设将oojs.js下载到了src目录中 --&gt;</span>
<span class="pl-s1">        &lt;<span class="pl-ent">script</span> <span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>text/javascript<span class="pl-pds">"</span></span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">"</span>./src/oojs.js<span class="pl-pds">"</span></span>&gt;&lt;/<span class="pl-ent">script</span>&gt;</span>
        <span class="pl-c">&lt;!-- 设置类文件根目录 --&gt;</span>
<span class="pl-s1">        &lt;<span class="pl-ent">script</span>&gt;</span>
<span class="pl-s1">            oojs.setPath(<span class="pl-s"><span class="pl-pds">'</span>http://localhost/src/<span class="pl-pds">'</span></span>);</span>
<span class="pl-s1">        &lt;/<span class="pl-ent">script</span>&gt;</span>
<span class="pl-s1">        &lt;<span class="pl-ent">script</span>&gt;</span>
<span class="pl-s1">                <span class="pl-c">//下面是main.js的内容, 可以将main直接写在页面里</span></span>
<span class="pl-s1">                oojs.define({</span>
<span class="pl-s1">                    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>main<span class="pl-pds">'</span></span>,</span>
<span class="pl-s1">                    deps<span class="pl-k">:</span> { template<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>utility.template<span class="pl-pds">'</span></span> },</span>
<span class="pl-s1">                    $<span class="pl-en">main</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){</span>
<span class="pl-s1">                        <span class="pl-k">var</span> result <span class="pl-k">=</span> <span class="pl-v">this</span>.template.render(<span class="pl-s"><span class="pl-pds">'</span>My name is {name}<span class="pl-pds">'</span></span>, {name<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>ZZQ<span class="pl-pds">'</span></span>});</span>
<span class="pl-s1">                        <span class="pl-en">console</span><span class="pl-c1">.log</span>(result);</span>
<span class="pl-s1">                    }</span>
<span class="pl-s1">                });</span>
<span class="pl-s1">        &lt;/<span class="pl-ent">script</span>&gt;</span>
    &lt;/<span class="pl-ent">body</span>&gt;
&lt;/<span class="pl-ent">html</span>&gt;</pre></div>

<p>打开 http://localhost/main.html页面, 即可在console控制台中看到:</p>

<div class="highlight highlight-js"><pre>    My name is <span class="pl-c1">ZZQ</span></pre></div>

<p>在浏览器中使用时, 需要设置类文件的根目录.oojs框架将从指定的根目录, 使用异步的方式加载类. 比如上面的例子加载 utility.template 类的地址是:</p>

<div class="highlight highlight-js"><pre>    http<span class="pl-k">:</span><span class="pl-c">//localhost/src/utility/template.js</span></pre></div>

<p>如果main有多个依赖类, 会同时并行异步加载, 并且在所有的类都加载完毕后在运行$main静态构造函数. </p>

<p>通过上面实例的详细讲解, 已经可以使用oojs编写简单可维护的js代码了.
下面的篇幅会介绍一些oojs细节和高级用法.</p>

<hr>

<h2>
<a id="类的加载路径" class="anchor" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%B7%AF%E5%BE%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>类的加载路径</h2>

<p>使用oojs的项目代码是用类组织的.在入门示例中, template.js 加载时, 默认使用如下路径:</p>

<p><strong><em>node:</em></strong>
[node运行的目录]/src/utility/template.js</p>

<p><strong><em>浏览器:</em></strong>
[页面当前域名]/src/utility/template.js</p>

<p>即无论是node还是浏览器, 在项目的根目录里创建src文件夹, src内根据命名空间来组织文件夹.</p>

<p>oojs提供了setPath函数, 可以为特定的类或者命名空间指定自己特殊的加载路径.</p>

<div class="highlight highlight-js"><pre><span class="pl-c">//设置全局根目录</span>
oojs.setPath(<span class="pl-s"><span class="pl-pds">'</span>./src2/<span class="pl-pds">'</span></span>);
oojs.setPath(<span class="pl-s"><span class="pl-pds">'</span>http://localhost/asset/js/<span class="pl-pds">'</span></span>);

<span class="pl-c">//为 A 和 A.B 命名空间设置特殊的加载路径</span>
oojs.setPath({
    <span class="pl-s"><span class="pl-pds">'</span>A<span class="pl-pds">'</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>./src1/A/<span class="pl-pds">'</span></span>,
    <span class="pl-s"><span class="pl-pds">'</span>A.B<span class="pl-pds">'</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>./src2/A/B/<span class="pl-pds">'</span></span>
});</pre></div>

<p>oojs的路径查找使用的是树状结构. 以"A.B.C"这个类的查找规则为例:</p>

<ul>
<li>首先从root根目录查找. 此时path为默认的src目录.</li>
<li>查找命名空间A, 发现通过setPath设置了A的路径, 此时path为上面设置的 './src1/A'</li>
<li>查找命名空间A.B, 发现通过setPath设置了A.B的路径, 此时path为上面设置的 './src2/A/B/'</li>
<li>查找命名空间A.B.C, 未发现A.B.C的路径, 于是使用上一步的path作为结果返回</li>
</ul>

<p>通过上面的查找行为可以看出, 优先使用更加精确的类的加载路径, 否则使用父路径.</p>

<hr>

<h1>
<a id="oojs的git源码结构" class="anchor" href="#oojs%E7%9A%84git%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>oojs的git源码结构</h1>

<h2>
<a id="bin目录" class="anchor" href="#bin%E7%9B%AE%E5%BD%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>bin目录</h2>

<p>bin目录中, 用于存放编译后的文件. bin目录下有以下两个js文件:</p>

<ul>
<li>oojs.core.js: 压缩后的文件. 仅包括核心的面向对象编程功能.</li>
<li>oojs.js: 压缩后的文件. 除了核心功能, 还包括loader类用于加载依赖类.以及event类用于处理事件编程. 通常都加载此文件.</li>
</ul>

<p>在bin的根目录下, 放置的是代码压缩后的js文件. 通常在项目中引用的就是代码压缩后的js文件. 同时为了应对一些比如调试等场景, bin目录下还包括如下文件夹: </p>

<ul>
<li>format文件夹: 格式化,但是无注释的编译结果</li>
<li>gzip文件夹: gzip后的编译结果</li>
<li>source文件夹: 包含注释的编译结果</li>
</ul>

<p>上面每一个文件夹中, 也都包含 oojs.core.js和oojs.js两个文件(gzip目录下是.gz后缀), 可以根据需要使用.</p>

<h2>
<a id="src目录" class="anchor" href="#src%E7%9B%AE%E5%BD%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>src目录</h2>

<p>src目录存放oojs的源码文件. oojs框架自身也是按照oojs的编程方式实现的, 即oojs是自解析的. </p>

<ul>
<li>oojs文件夹 : oojs命名空间

<ul>
<li>event.js : oojs.event类实现了事件编程和promise编程模式. 这是异步编程时必不可少的类.</li>
<li>loader.js : oojs.loader类提供了浏览器环境加载依赖类的加载器. </li>
</ul>
</li>
<li>oojs.js : oojs的核心编程框架. oojs.core.js就是直接从这个文件编译出来的.</li>
</ul>

<h2>
<a id="项目根目录" class="anchor" href="#%E9%A1%B9%E7%9B%AE%E6%A0%B9%E7%9B%AE%E5%BD%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目根目录</h2>

<p>bin和src两个目录是最主要的文件夹. 除了这两个文件夹, oojs的项目根目录还包括如下文件:</p>

<ul>
<li><p>.gitignore: git配置文件, 里面写明了git不需要管理的文件. 比如 node_modules 文件夹.</p></li>
<li><p>README.md: 说明文档. 即您正在阅读的这个页面的内容.</p></li>
<li><p>make.js: 编译文件. 使用 node make.js 命令, 可以从src目录生成bin目录下面的所有文件.</p></li>
<li><p>package.json: 包描述文件.</p></li>
</ul>

<hr>

<h1>
<a id="事件函数与this指针" class="anchor" href="#%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%B8%8Ethis%E6%8C%87%E9%92%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>事件函数与this指针</h1>

<p>假设我们声明了一个类:</p>

<div class="highlight highlight-js"><pre>    oojs.define({
        name<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>myClass<span class="pl-pds">'</span></span>,
        word<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Hello World<span class="pl-pds">'</span></span>,
        <span class="pl-en">say</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
            <span class="pl-c1">alert</span>(<span class="pl-v">this</span>.word);
        }
    })</pre></div>

<p>myClss类有一个say函数, 输出myClass类的word属性. say函数中通过this引用myClass类自身. 这在通常情况下都是正确的.</p>

<p>但是在事件中, 比如常见的按钮单击事件, 或者一个定时器函数, this指针并不是总指向myClass自身的:</p>

<div class="highlight highlight-js"><pre>    <span class="pl-c1">window</span>.word <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>I am window<span class="pl-pds">'</span></span>;
    <span class="pl-k">var</span> myClass <span class="pl-k">=</span> oojs.using(<span class="pl-s"><span class="pl-pds">'</span>myClass<span class="pl-pds">'</span></span>);
    <span class="pl-c1">setTimeout</span>(myClass.say, <span class="pl-c1">1000</span>);</pre></div>

<p>上面的代码会输出"I am window"而不是myClass类中的"Hello World". 因为在setTimeout中的this指向了window对象而不是myClass.</p>

<p>oojs提供了proxy函数用于解决this指针问题. 默认情况下为了使用方便, 会为function的原型添加proxy函数. 如果不希望对原型造成污染也可以通过配置取消此功能. </p>

<p>proxy函数用来修改事件的this指针. 比如上面的代码可以这样修改:</p>

<div class="highlight highlight-js"><pre>    <span class="pl-k">var</span> myClass <span class="pl-k">=</span> oojs.using(<span class="pl-s"><span class="pl-pds">'</span>myClass<span class="pl-pds">'</span></span>);
    <span class="pl-c1">setTimeout</span>(myClass.say.proxy(myClass), <span class="pl-c1">1000</span>);</pre></div>

<p>使用了proxy之后, 可以正常的输出"Hello World".</p>

<p>proxy函数的第一个参数表示this指针需要指向的对象. </p>

<p>proxy函数还可以 <strong><em>修改事件处理函数的签名</em></strong> , 下面举一个复杂的例子.</p>

<p>在nodejs中, 系统提供了socket对象, 用于网络编程. </p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> net <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>net<span class="pl-pds">'</span></span>);
<span class="pl-k">var</span> client <span class="pl-k">=</span> net.connect({port<span class="pl-k">:</span> <span class="pl-c1">8124</span>},
    <span class="pl-k">function</span>() { <span class="pl-c">//'connect' listener</span>
          <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">'</span>client connected<span class="pl-pds">'</span></span>);
          client.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">'</span>world!<span class="pl-cce">\r\n</span><span class="pl-pds">'</span></span>);
});</pre></div>

<p>调用 net.connect函数时, 需要传递一个回调函数, 并且回调函数是无参数的.
通常, 使用上面的例子, 我们传递了一个匿名的回调函数, 并且在这个回调函数中使用 client变量, 此时会生成一个闭包, 以便在回调函数执行时, 可以正确访问到client变量.</p>

<p>使用proxy函数, 可以用一种 <strong><em>显式闭包</em></strong> 的方式, 将client作为参数传递, 让其看起来是通过参数传递的而不是使用闭包:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> net <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>net<span class="pl-pds">'</span></span>);
<span class="pl-k">var</span> client <span class="pl-k">=</span> net.connect({port<span class="pl-k">:</span> <span class="pl-c1">8124</span>},
    <span class="pl-k">function</span>(<span class="pl-smi">mySocket</span>) { <span class="pl-c">//'connect' listener</span>
          <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">'</span>client connected<span class="pl-pds">'</span></span>);
          mySocket.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">'</span>world!<span class="pl-cce">\r\n</span><span class="pl-pds">'</span></span>);
}.proxy(<span class="pl-v">this</span>, client));</pre></div>

<p>注意, 这里通过proxy除了传递this对象外, 还传递了client变量.
connect原本的回调函数是没有签名的, 但是你会发现在回调函数执行时, mySocket可以被正常访问. 此时我们将原本无参数的事件处理函数, 变成了一个有参数的事件处理函数. </p>

<p>proxy函数看似神奇,其实内部还是使用闭包实现. 所以我在这里称其为 <strong><em>显式闭包</em></strong> .
使用显示闭包极大的增加了代码的可读性和可维护性. 可以说显示闭包让邪恶的闭包从良了.</p>

<p>另外, 显示闭包还可以解决循环中使用闭包的常见错误, 看下面的例子:
(参见:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a>)</p>

<div class="highlight highlight-html"><pre>&lt;<span class="pl-ent">p</span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>help<span class="pl-pds">"</span></span>&gt;Helpful notes will appear here&lt;/<span class="pl-ent">p</span>&gt;
&lt;<span class="pl-ent">p</span>&gt;E-mail: &lt;<span class="pl-ent">input</span> <span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>text<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>email<span class="pl-pds">"</span></span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>email<span class="pl-pds">"</span></span>&gt;&lt;/<span class="pl-ent">p</span>&gt;
&lt;<span class="pl-ent">p</span>&gt;Name: &lt;<span class="pl-ent">input</span> <span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>text<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>&gt;&lt;/<span class="pl-ent">p</span>&gt;
&lt;<span class="pl-ent">p</span>&gt;Age: &lt;<span class="pl-ent">input</span> <span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>text<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>age<span class="pl-pds">"</span></span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>age<span class="pl-pds">"</span></span>&gt;&lt;/<span class="pl-ent">p</span>&gt;</pre></div>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">showHelp</span>(<span class="pl-smi">help</span>) {
  <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>(<span class="pl-s"><span class="pl-pds">'</span>help<span class="pl-pds">'</span></span>).innerHTML <span class="pl-k">=</span> help;
}

<span class="pl-k">function</span> <span class="pl-en">setupHelp</span>() {
  <span class="pl-k">var</span> helpText <span class="pl-k">=</span> [
      {<span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>email<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>help<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Your e-mail address<span class="pl-pds">'</span></span>},
      {<span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>help<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Your full name<span class="pl-pds">'</span></span>},
      {<span class="pl-s"><span class="pl-pds">'</span>id<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>age<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>help<span class="pl-pds">'</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Your age (you must be over 16)<span class="pl-pds">'</span></span>}
    ];

  <span class="pl-k">for</span> (<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> helpText.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
    <span class="pl-k">var</span> item <span class="pl-k">=</span> helpText[i];
    <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>(item.<span class="pl-c1">id</span>).<span class="pl-en">onfocus</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
      <span class="pl-c1">showHelp</span>(item.help);
    }
  }
}

setupHelp();</pre></div>

<p>数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。</p>

<p>运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。</p>

<p>该问题的原因在于赋给 onfocus 是闭包（showHelp）中的匿名函数而不是闭包对象；在闭包（showHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。</p>

<p>使用proxy函数就不会出现上面的问题:</p>

<div class="highlight highlight-js"><pre>    <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>(item.<span class="pl-c1">id</span>).<span class="pl-en">onfocus</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">ev</span>, <span class="pl-smi">item</span>) {
      <span class="pl-c1">showHelp</span>(item.help);
    }.proxy(<span class="pl-v">this</span>, item);</pre></div>

<p>特别要注意, proxy函数只能在原有的事件处理函数后面新增参数. onfocus事件原本是包括一个事件对象参数的. 即上面的ev. 所以需要将item作为第二个函数参数使用.</p>

<p>相对于传统的node变成, 下面来看看使用oojs实现的完整的socket服务器的例子:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>node-oojs<span class="pl-pds">'</span></span>);


oojs.define({
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>socketServer<span class="pl-pds">'</span></span>,    
    <span class="pl-c">/**</span>
<span class="pl-c">     * 静态构造函数</span>
<span class="pl-c">     */</span>
    $<span class="pl-en">socketServer</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
        <span class="pl-k">var</span> net <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>net<span class="pl-pds">'</span></span>);

        <span class="pl-c">//启动服务</span>
        <span class="pl-v">this</span>.server <span class="pl-k">=</span> net.createServer();
        <span class="pl-v">this</span>.server.on(<span class="pl-s"><span class="pl-pds">'</span>connection<span class="pl-pds">'</span></span>, <span class="pl-v">this</span>.onConnection.proxy(<span class="pl-v">this</span>));
        <span class="pl-v">this</span>.server.on(<span class="pl-s"><span class="pl-pds">'</span>error<span class="pl-pds">'</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">onError</span>.proxy(<span class="pl-v">this</span>));
        <span class="pl-v">this</span>.server.listen(<span class="pl-c1">8088</span>, <span class="pl-k">function</span> () {
            base<span class="pl-c1">.log.info</span>(<span class="pl-s"><span class="pl-pds">'</span>server bound<span class="pl-pds">'</span></span>);
        });
    },

    <span class="pl-c">/**</span>
<span class="pl-c">     * 服务器连接事件处理函数. </span>
<span class="pl-c">     * <span class="pl-k">@param</span> {Object} socket 本次连接的socket对象</span>
<span class="pl-c">     */</span>
    <span class="pl-en">onConnection</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">socket</span>) {
        socket.on(<span class="pl-s"><span class="pl-pds">'</span>data<span class="pl-pds">'</span></span>, <span class="pl-v">this</span>.onData.proxy(<span class="pl-v">this</span>, socket));
        socket.on(<span class="pl-s"><span class="pl-pds">'</span>end<span class="pl-pds">'</span></span>, <span class="pl-v">this</span>.onEnd.proxy(<span class="pl-v">this</span>, socket));
        socket.on(<span class="pl-s"><span class="pl-pds">'</span>error<span class="pl-pds">'</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">onError</span>.proxy(<span class="pl-v">this</span>, socket));
    },

     <span class="pl-c">/**</span>
<span class="pl-c">     * socket接收数据事件处理函数. </span>
<span class="pl-c">     * <span class="pl-k">@param</span> {Object} data 本次介绍到的数据对象buffer</span>
<span class="pl-c">     * <span class="pl-k">@param</span> {Object} socket 本次连接的socket对象</span>
<span class="pl-c">     */</span>
    <span class="pl-en">onData</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">data</span>, <span class="pl-smi">socket</span>) {
        <span class="pl-c">//do something...</span>
    },

    <span class="pl-c">/**</span>
<span class="pl-c">     * socket 关闭事件处理函数. </span>
<span class="pl-c">     * <span class="pl-k">@param</span> {Object} socket 本次连接的socket对象</span>
<span class="pl-c">     */</span>
    <span class="pl-en">onEnd</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">socket</span>) {
        <span class="pl-c">//do something...</span>
    },

    <span class="pl-c">/**</span>
<span class="pl-c">     * socket 异常事件处理函数. </span>
<span class="pl-c">     * <span class="pl-k">@param</span> {Object} err 异常对象</span>
<span class="pl-c">     * <span class="pl-k">@param</span> {Object} socket 本次连接的socket对象</span>
<span class="pl-c">     */</span>
    <span class="pl-en">onError</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">err</span>, <span class="pl-smi">socket</span>) {
        <span class="pl-c">//do something...</span>
    }
});</pre></div>

<hr>

<h1>
<a id="oojs的原型继承和快速克隆" class="anchor" href="#oojs%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%BF%AB%E9%80%9F%E5%85%8B%E9%9A%86" aria-hidden="true"><span class="octicon octicon-link"></span></a>oojs的原型继承和快速克隆</h1>

<p>oojs中使用特有的快速克隆方法实现高效的对象创建. 主要用在内部的oojs.create函数中, 此函数用于创建一个类实例.</p>

<p>假设a是classA的一个实例. 此时的原型链情况如下:</p>

<pre><code>a.contructor.prototype-&gt;classA
</code></pre>

<p>当访问a的一个属性时, 有以下几种情况:</p>

<ol>
<li>属性是值类型:
访问: 通过原型链获取到classA的属性
赋值: 在a对象上设置新的属性值, 再次访问时获取到的是a对象上的新值</li>
<li>属性是引用类型(比如object类型):
访问: 通过原型链获取到classA的属性
赋值: 因为是引用类型, 所以实际上是对classA上的引用对象赋值. 即classA被修改, 所有实例的此属性都被修改</li>
</ol>

<p>为了解决此问题, oojs在创建classA的实例时, 会遍历classA的属性, 如果发现属性的类型是引用类型, 则对其进行快速克隆:</p>

<div class="highlight highlight-js"><pre>        <span class="pl-c">/**</span>
<span class="pl-c">         * 快速克隆方法</span>
<span class="pl-c">         * @public</span>
<span class="pl-c">         * <span class="pl-k">@method</span> fastClone</span>
<span class="pl-c">         * <span class="pl-k">@param</span> {Object} source 带克隆的对象. 使用此方法克隆出来的对象, 如果source对象被修改, 则所有克隆对象也会被修改</span>
<span class="pl-c">         * <span class="pl-k">@return</span> {Object} 克隆出来的对象.</span>
<span class="pl-c">         */</span>
        <span class="pl-en">fastClone</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">source</span>) {
            <span class="pl-k">var</span> <span class="pl-en">temp</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {};
            <span class="pl-c1">temp</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> source;
            <span class="pl-k">var</span> result <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">temp</span>();
        }</pre></div>

<p>传统的克隆对象是十分消耗性能的, oojs的最初也是用了传统的克隆方法. 最后改进成使用快速克隆方法. </p>

<p>假设这个属性为A, 此时相当于将属性A作为类, 创建了一个属性A的实例, 即关系是:</p>

<pre><code>a.A.constructor.prototype -&gt; classA.A 
</code></pre>

<p>此时, 如果A的所有属性都不是引用类型, 则可以解决上面的赋值问题.
但是如果属性A本身, 又含有引用类型, 则同样会出现赋值是修改原形的问题. 
假设: A.B为object
则通过 a.A.B 获取到的对象与 classA.A.B 获取到的对象是同一个对象. 对于a.A.B的修改同样会影响到classA.A.B
通过递归的快速克隆可以解决此问题, 但是因为性能开销太大, 所以oojs最后不支持多层的对象嵌套. </p>

<p>实际上, 我们可以通过编程方式来解决这个问题.</p>

<ul>
<li>在类声明时赋值的属性, 即JSON中直接描述的属性值, 应该是静态static类型. 不应在运行时修改.</li>
<li>如果一个属性是实例属性, 则应该在动态构造函数中赋值.比如:</li>
</ul>

<div class="highlight highlight-js"><pre>oojs.define({
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>classA<span class="pl-pds">'</span></span>
    A<span class="pl-k">:</span> <span class="pl-c1">null</span>
    <span class="pl-en">classA</span><span class="pl-k">:</span><span class="pl-k">function</span>(){
        <span class="pl-v">this</span>.A <span class="pl-k">=</span> { B<span class="pl-k">:</span><span class="pl-c1">1</span> }
    }
});</pre></div>

<p>所以一定要注意, 如果类的属性是对象, 并且是实例属性(运行时会被修改),则必须在动态构造函数中创建.</p>

<p>另改一个问题就是a对象的遍历. 同样因为使用了原型继承, 不能够通过hasOwnProperty来判断一个属性是否是实例a的. 可以通过遍历classA来解决:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span>(<span class="pl-k">var</span> key <span class="pl-k">in</span> a){
    <span class="pl-k">if</span>(key <span class="pl-k">&amp;&amp;</span> <span class="pl-k">typeof</span> a[key] <span class="pl-k">!==</span> <span class="pl-s"><span class="pl-pds">'</span>undefined<span class="pl-pds">'</span></span> <span class="pl-k">&amp;&amp;</span> classA.hasOwnProperty(key)){
        <span class="pl-c">//do something...</span>
    }
}</pre></div>

<hr>

<h1>
<a id="事件编程" class="anchor" href="#%E4%BA%8B%E4%BB%B6%E7%BC%96%E7%A8%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>事件编程</h1>

<p>js中常常使用事件和异步, 在浏览器端的Ajax是异步, 在nodejs中更是到处都是异步事件.</p>

<p>在异步事件的编程中, 常常会遇到多层嵌套的情况. 比如:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> <span class="pl-en">render</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">template</span>, <span class="pl-smi">data</span>, <span class="pl-smi">l10n</span>) {
  <span class="pl-c">//do something...</span>
};

$.get(<span class="pl-s"><span class="pl-pds">"</span>template<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">template</span>) {
  <span class="pl-c">// something</span>
  $.get(<span class="pl-s"><span class="pl-pds">"</span>data<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">data</span>) {
    <span class="pl-c">// something</span>
    $.get(<span class="pl-s"><span class="pl-pds">"</span>l10n<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">l10n</span>) {
      <span class="pl-c">// something</span>
      render(template, data, l10n);
    });
  });
});</pre></div>

<p>在异步的世界里, 需要在回调函数中获取调用结果, 然后再进行接下来的处理流程, 所以导致了回调函数的多层嵌套, 并且只能串行处理.</p>

<p>oojs提供了oojs.event, 来解决此问题. 比如要实现上面的功能, 可以进行如下改造:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> <span class="pl-en">render</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">template</span>, <span class="pl-smi">data</span>, <span class="pl-smi">l10n</span>) {
  <span class="pl-c">//do something...</span>
};

<span class="pl-k">var</span> ev <span class="pl-k">=</span> oojs.create(oojs.<span class="pl-c1">event</span>);
ev.bind(<span class="pl-s"><span class="pl-pds">'</span>l10n<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    ev.emit(<span class="pl-s"><span class="pl-pds">'</span>l10n<span class="pl-pds">'</span></span>, data);
});
ev.bind(<span class="pl-s"><span class="pl-pds">'</span>data<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    ev.emit(<span class="pl-s"><span class="pl-pds">'</span>data<span class="pl-pds">'</span></span>, data);
});
ev.bind(<span class="pl-s"><span class="pl-pds">'</span>template<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    ev.emit(<span class="pl-s"><span class="pl-pds">'</span>template<span class="pl-pds">'</span></span>, data);
});
<span class="pl-c">//并行执行template, data和l10n事件, 都执行完毕后会触发group中的回调函数</span>
ev.group(<span class="pl-s"><span class="pl-pds">'</span>myGroup<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>template<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>data<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>l10n<span class="pl-pds">'</span></span>], <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    render(data.template, data.<span class="pl-c1">data</span>, data.l10n);
});</pre></div>

<p>oojs.event的group可以将事件打包成一组. 在group的回调函数中, 会传递一个参数data, 这是一个object对象, 其中key为group中绑定的每一个事件名, value为事件的返回值. 所以可以通过data[事件名]获取到某一个事件的返回值. </p>

<p>oojs.event中的group还可以动态添加新的事件. 比如:</p>

<div class="highlight highlight-js"><pre>ev.group(<span class="pl-s"><span class="pl-pds">'</span>myGroup<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>template<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>data<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>l10n<span class="pl-pds">'</span></span>], <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    render(data.template, data.<span class="pl-c1">data</span>, data.l10n);
});

ev.group(<span class="pl-s"><span class="pl-pds">'</span>myGroup<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>another<span class="pl-pds">'</span></span>], <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    anotherData <span class="pl-k">=</span> data.another;
});</pre></div>

<p>注意上面的代码, 虽然为myGroup又添加了一个another事件. 但是此时mygroup绑定了两个事件处理函数, 这两个函数都会在所有事件完成时执行, 但是不一定哪个在前. 所以oojs.event还提供了afterGroup事件, 此事件会在所有group绑定的callback执行完毕后再执行:</p>

<div class="highlight highlight-js"><pre>ev.group(<span class="pl-s"><span class="pl-pds">'</span>myGroup<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>template<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>data<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>l10n<span class="pl-pds">'</span></span>]);

ev.group(<span class="pl-s"><span class="pl-pds">'</span>myGroup<span class="pl-pds">'</span></span>, [<span class="pl-s"><span class="pl-pds">'</span>another<span class="pl-pds">'</span></span>]);

ev.afterGroup(<span class="pl-s"><span class="pl-pds">'</span>myGroup<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    render(data.template, data.<span class="pl-c1">data</span>, data.l10n, data.another);
});</pre></div>

<p>oojs.event使用oo的思想实现. node中本身自带EventEmmiter也实现了部分功能. </p>

<hr>

<h1>
<a id="为什么要用面向对象的思想写js" class="anchor" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3%E5%86%99js" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么要用面向对象的思想写js?</h1>

<p>oo不仅仅是一种编程方法, 而是组织代码的最小单位. </p>

<p>看几个使用AMD规范的例子就会明白, AMD中最后一个参数factory虽然美其名曰构造函数, 但是在这个函数中, 你可以做任何事情:创建局部function, function中再嵌套function, 使用闭包, 处理一些业务逻辑. 最后的结果是这个factory不易阅读和维护.</p>

<p>究其原因, js编程很容易陷入面向过程编程的方式中. 而AMD等规范只注重"模块"的开发, 却忽视了一个模块内部的代码如何组织和管理.</p>

<p>js中让代码不易管理的几个杀手包括: 闭包, 零散的函数对象, 异步机制(node中尤其重要).</p>

<p>oojs使用oo的思想, 减少闭包的使用, 让每一个函数对象都挂靠在类对象上, 减少孤零的函数对象的存在. 再配合oojs.event的事件机制, 解决异步编程中的事件嵌套噩梦.</p>

<p>可以说oojs为js的大规模开发提供了有效地基础保障.</p>

<hr>

<h1>
<a id="加入我们" class="anchor" href="#%E5%8A%A0%E5%85%A5%E6%88%91%E4%BB%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>加入我们</h1>

<p>oojs还在发展中, 我们尽量不在核心的oojs.js中加入过多的功能, 保持核心精简. 同时通过oojs团队成员的努力, 让oojs适用于更多的场景. </p>

<p>欢迎有志之士加入到oojs的开发中来! </p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/zhangziqiu/oojs">oojs</a> is maintained by <a href="https://github.com/zhangziqiu">zhangziqiu</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

